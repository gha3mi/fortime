var tipuesearch = {"pages":[{"title":" ForTime ","text":"ForTime ForTime : A Fortran library for measuring elapsed time, CPU time, OMP time and MPI time. fpm dependency If you want to use ForTime as a dependency in your own fpm project,\nyou can easily include it by adding the following line to your fpm.toml file: [dependencies] fortime = { git = \"https://github.com/gha3mi/fortime.git\" } Usage Measuring elapsed time To measure the elapsed wall-clock time, use the following: use fortime type ( timer ) :: t call t % timer_start () ! Your code or section to be timed call t % timer_stop () Measuring CPU time To measure the CPU time consumed by your code, use these functions: use fortime type ( timer ) :: t call t % ctimer_start () ! Your code or section to be timed call t % ctimer_stop () Measuring OpenMP (OMP) time If your code includes OpenMP parallelization, you can measure the time taken by the parallel regions using: use fortime type ( timer ) :: t call t % otimer_start () ! Your code or section to be timed call t % otimer_stop () Note: Ensure you compile with the -DOMP option when using the OpenMP timer. Measuring MPI time When using MPI (Message Passing Interface), you can measure the time taken by your MPI processes using: use fortime type ( timer ) :: t call t % mtimer_start () ! Your code or section to be timed call t % mtimer_stop () Note: Don't forget to compile with the -DMPI option when using the MPI timer. How to run examples Clone the repository: You can clone the ForTime repository from GitHub using the following command: git clone https://github.com/gha3mi/fortime.git cd fortime For Intel Fortran Compiler (ifort): shell\n  fpm @ifort-example For Intel Fortran Compiler (ifx): shell\n  fpm @ifx-example For NVIDIA Compiler (nvfortran): shell\n  fpm @nvfortran-example For GNU Fortran Compiler (gfortran): shell\n  fpm @gfortran-example API documentation The most up-to-date API documentation for the master branch is available here .\nTo generate the API documentation for ForTime using ford run the following\ncommand: ford ford.yml Contributing Contributions to ForTime are welcome! If you find any issues or would like to suggest improvements, please open an issue. Developer Info Seyed Ali Ghasemi","tags":"home","loc":"index.html"},{"title":"timer – ForTime ","text":"type, public :: timer Components Type Visibility Attributes Name Initial integer, public :: clock_rate integer, public :: clock_start integer, public :: clock_end integer, public :: clock_elapsed real(kind=rk), public :: elapsed_time real(kind=rk), public :: cpu_start real(kind=rk), public :: cpu_end real(kind=rk), public :: cpu_elapsed real(kind=rk), public :: cpu_time real(kind=rk), public :: omp_start real(kind=rk), public :: omp_end real(kind=rk), public :: omp_elapsed real(kind=rk), public :: omp_time real(kind=rk), public :: mpi_start real(kind=rk), public :: mpi_end real(kind=rk), public :: mpi_elapsed real(kind=rk), public :: mpi_time Type-Bound Procedures procedure, public :: timer_start public impure subroutine timer_start (this) Author Seyed Ali Ghasemi Starts the timer by recording the current processor clock value.\nThis value is used to calculate the elapsed time later. Arguments Type Intent Optional Attributes Name class( timer ), intent(inout) :: this procedure, public :: timer_stop public impure subroutine timer_stop (this, nloops, message) Author Seyed Ali Ghasemi Stops the timer and calculates the elapsed time.\nOptionally, it can print a message along with the elapsed time. Arguments Type Intent Optional Attributes Name class( timer ), intent(inout) :: this integer, intent(in), optional :: nloops character(len=*), intent(in), optional :: message procedure, public :: timer_write private impure subroutine timer_write (this, file_name) Author Seyed Ali Ghasemi Writes the elapsed time to a file. Arguments Type Intent Optional Attributes Name class( timer ), intent(in) :: this character(len=*), intent(in) :: file_name procedure, public :: ctimer_start private impure subroutine ctimer_start (this) Author Seyed Ali Ghasemi Starts the timer by recording the current CPU time value.\nThis value is used to calculate the CPU time later. Arguments Type Intent Optional Attributes Name class( timer ), intent(inout) :: this procedure, public :: ctimer_stop private impure subroutine ctimer_stop (this, nloops, message) Author Seyed Ali Ghasemi Stops the timer and calculates the CPU time.\nOptionally, it can print a message along with the CPU time. Arguments Type Intent Optional Attributes Name class( timer ), intent(inout) :: this integer, intent(in), optional :: nloops character(len=*), intent(in), optional :: message procedure, public :: ctimer_write private impure subroutine ctimer_write (this, file_name) Author Seyed Ali Ghasemi Writes the CPU time to a file. Arguments Type Intent Optional Attributes Name class( timer ), intent(in) :: this character(len=*), intent(in) :: file_name procedure, public :: otimer_start private impure subroutine otimer_start (this) Author Seyed Ali Ghasemi Starts the timer by recording the current OMP time value.\nThis value is used to calculate the OMP time later. Arguments Type Intent Optional Attributes Name class( timer ), intent(inout) :: this procedure, public :: otimer_stop private impure subroutine otimer_stop (this, nloops, message) Author Seyed Ali Ghasemi Stops the timer and calculates the OMP time.\nOptionally, it can print a message along with the OMP time. Arguments Type Intent Optional Attributes Name class( timer ), intent(inout) :: this integer, intent(in), optional :: nloops character(len=*), intent(in), optional :: message procedure, public :: otimer_write private impure subroutine otimer_write (this, file_name) Author Seyed Ali Ghasemi Writes the OMP time to a file. Arguments Type Intent Optional Attributes Name class( timer ), intent(in) :: this character(len=*), intent(in) :: file_name procedure, public :: mtimer_start private impure subroutine mtimer_start (this) Author Seyed Ali Ghasemi Starts the timer by recording the current MPI time value.\nThis value is used to calculate the MPI time later. Arguments Type Intent Optional Attributes Name class( timer ), intent(inout) :: this procedure, public :: mtimer_stop private impure subroutine mtimer_stop (this, nloops, message) Author Seyed Ali Ghasemi Stops the timer and calculates the MPI time.\nOptionally, it can print a message along with the MPI time. Arguments Type Intent Optional Attributes Name class( timer ), intent(inout) :: this integer, intent(in), optional :: nloops character(len=*), intent(in), optional :: message procedure, public :: mtimer_write private impure subroutine mtimer_write (this, file_name) Author Seyed Ali Ghasemi Writes the MPI time to a file. Arguments Type Intent Optional Attributes Name class( timer ), intent(in) :: this character(len=*), intent(in) :: file_name","tags":"","loc":"type/timer.html"},{"title":"timer_start – ForTime","text":"public impure subroutine timer_start(this) Starts the timer by recording the current processor clock value.\nThis value is used to calculate the elapsed time later. Type Bound timer Arguments Type Intent Optional Attributes Name class( timer ), intent(inout) :: this Called by proc~~timer_start~~CalledByGraph proc~timer_start fortime::timer%timer_start program~example1 example1 program~example1->proc~timer_start program~example2 example2 program~example2->proc~timer_start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine timer_start ( this ) class ( timer ), intent ( inout ) :: this ! Get the processor clock rate call system_clock ( count_rate = this % clock_rate ) ! Start the timer call system_clock ( count = this % clock_start ) end subroutine timer_start","tags":"","loc":"proc/timer_start.html"},{"title":"timer_stop – ForTime","text":"public impure subroutine timer_stop(this, nloops, message) Stops the timer and calculates the elapsed time.\nOptionally, it can print a message along with the elapsed time. Type Bound timer Arguments Type Intent Optional Attributes Name class( timer ), intent(inout) :: this integer, intent(in), optional :: nloops character(len=*), intent(in), optional :: message Called by proc~~timer_stop~~CalledByGraph proc~timer_stop fortime::timer%timer_stop program~example1 example1 program~example1->proc~timer_stop program~example2 example2 program~example2->proc~timer_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine timer_stop ( this , nloops , message ) class ( timer ), intent ( inout ) :: this integer , intent ( in ), optional :: nloops character ( * ), intent ( in ), optional :: message character (:), allocatable :: msg ! Stop the timer call system_clock ( count = this % clock_end ) ! Calculate the elapsed processor ticks this % clock_elapsed = this % clock_end - this % clock_start ! Convert processor ticks to seconds if (. not . present ( nloops )) & this % elapsed_time = real ( this % clock_elapsed , kind = rk ) / real ( this % clock_rate , kind = rk ) if ( present ( nloops )) & this % elapsed_time = real ( this % clock_elapsed , kind = rk ) / real ( this % clock_rate , kind = rk ) / real ( nloops , kind = rk ) ! Print the elapsed time if (. not . present ( message )) then msg = \"Elapsed time:\" else msg = message end if print '(A, F7.3, \" [s]\")' , trim ( msg ), this % elapsed_time ! Deallocate the message if ( allocated ( msg )) deallocate ( msg ) end subroutine timer_stop","tags":"","loc":"proc/timer_stop.html"},{"title":"timer_write – ForTime","text":"private impure subroutine timer_write(this, file_name) Writes the elapsed time to a file. Type Bound timer Arguments Type Intent Optional Attributes Name class( timer ), intent(in) :: this character(len=*), intent(in) :: file_name Called by proc~~timer_write~~CalledByGraph proc~timer_write fortime::timer%timer_write program~example2 example2 program~example2->proc~timer_write Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine timer_write ( this , file_name ) class ( timer ), intent ( in ) :: this character ( * ), intent ( in ) :: file_name logical :: file_exists integer :: nunit ! Check if the file exists inquire ( file = file_name , exist = file_exists ) ! Open the file in appropriate mode if ( file_exists ) then open ( newunit = nunit , file = file_name , status = 'old' , action = 'write' , position = 'append' ) else open ( newunit = nunit , file = file_name , status = 'new' , action = 'write' ) end if ! Write the elapsed time to the file write ( nunit , '(g0)' ) this % elapsed_time ! Close the file close ( nunit ) end subroutine timer_write","tags":"","loc":"proc/timer_write.html"},{"title":"ctimer_start – ForTime","text":"private impure subroutine ctimer_start(this) Starts the timer by recording the current CPU time value.\nThis value is used to calculate the CPU time later. Type Bound timer Arguments Type Intent Optional Attributes Name class( timer ), intent(inout) :: this Called by proc~~ctimer_start~~CalledByGraph proc~ctimer_start fortime::timer%ctimer_start program~example3 example3 program~example3->proc~ctimer_start program~example4 example4 program~example4->proc~ctimer_start Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine ctimer_start ( this ) class ( timer ), intent ( inout ) :: this ! Start the timer call cpu_time ( this % cpu_start ) end subroutine ctimer_start","tags":"","loc":"proc/ctimer_start.html"},{"title":"ctimer_stop – ForTime","text":"private impure subroutine ctimer_stop(this, nloops, message) Stops the timer and calculates the CPU time.\nOptionally, it can print a message along with the CPU time. Type Bound timer Arguments Type Intent Optional Attributes Name class( timer ), intent(inout) :: this integer, intent(in), optional :: nloops character(len=*), intent(in), optional :: message Called by proc~~ctimer_stop~~CalledByGraph proc~ctimer_stop fortime::timer%ctimer_stop program~example3 example3 program~example3->proc~ctimer_stop program~example4 example4 program~example4->proc~ctimer_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine ctimer_stop ( this , nloops , message ) class ( timer ), intent ( inout ) :: this integer , intent ( in ), optional :: nloops character ( * ), intent ( in ), optional :: message character (:), allocatable :: msg ! Stop the timer call cpu_time ( this % cpu_end ) ! Calculate the elapsed CPU time this % cpu_elapsed = this % cpu_end - this % cpu_start ! Convert CPU time to seconds if (. not . present ( nloops )) this % cpu_time = this % cpu_elapsed if ( present ( nloops )) this % cpu_time = this % cpu_elapsed / real ( nloops , kind = rk ) ! Print the elapsed time if (. not . present ( message )) then msg = \"CPU time:\" else msg = message end if print '(A, F16.9, \" [s]\")' , trim ( msg ), this % cpu_time ! Deallocate the message if ( allocated ( msg )) deallocate ( msg ) end subroutine ctimer_stop","tags":"","loc":"proc/ctimer_stop.html"},{"title":"ctimer_write – ForTime","text":"private impure subroutine ctimer_write(this, file_name) Writes the CPU time to a file. Type Bound timer Arguments Type Intent Optional Attributes Name class( timer ), intent(in) :: this character(len=*), intent(in) :: file_name Called by proc~~ctimer_write~~CalledByGraph proc~ctimer_write fortime::timer%ctimer_write program~example4 example4 program~example4->proc~ctimer_write Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine ctimer_write ( this , file_name ) class ( timer ), intent ( in ) :: this character ( * ), intent ( in ) :: file_name logical :: file_exists integer :: nunit ! Check if the file exists inquire ( file = file_name , exist = file_exists ) ! Open the file in appropriate mode if ( file_exists ) then open ( newunit = nunit , file = file_name , status = 'old' , action = 'write' , position = 'append' ) else open ( newunit = nunit , file = file_name , status = 'new' , action = 'write' ) end if ! Write the CPU time to the file write ( nunit , '(g0)' ) this % cpu_time ! Close the file close ( nunit ) end subroutine ctimer_write","tags":"","loc":"proc/ctimer_write.html"},{"title":"otimer_start – ForTime","text":"private impure subroutine otimer_start(this) Uses omp_lib proc~~otimer_start~~UsesGraph proc~otimer_start fortime::timer%otimer_start omp_lib omp_lib proc~otimer_start->omp_lib Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Starts the timer by recording the current OMP time value.\nThis value is used to calculate the OMP time later. Type Bound timer Arguments Type Intent Optional Attributes Name class( timer ), intent(inout) :: this Calls proc~~otimer_start~~CallsGraph proc~otimer_start fortime::timer%otimer_start omp_get_wtime omp_get_wtime proc~otimer_start->omp_get_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine otimer_start ( this ) use omp_lib class ( timer ), intent ( inout ) :: this ! Start the timer this % omp_start = omp_get_wtime () end subroutine otimer_start","tags":"","loc":"proc/otimer_start.html"},{"title":"otimer_stop – ForTime","text":"private impure subroutine otimer_stop(this, nloops, message) Uses omp_lib proc~~otimer_stop~~UsesGraph proc~otimer_stop fortime::timer%otimer_stop omp_lib omp_lib proc~otimer_stop->omp_lib Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Stops the timer and calculates the OMP time.\nOptionally, it can print a message along with the OMP time. Type Bound timer Arguments Type Intent Optional Attributes Name class( timer ), intent(inout) :: this integer, intent(in), optional :: nloops character(len=*), intent(in), optional :: message Calls proc~~otimer_stop~~CallsGraph proc~otimer_stop fortime::timer%otimer_stop omp_get_wtime omp_get_wtime proc~otimer_stop->omp_get_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine otimer_stop ( this , nloops , message ) use omp_lib class ( timer ), intent ( inout ) :: this integer , intent ( in ), optional :: nloops character ( * ), intent ( in ), optional :: message character (:), allocatable :: msg ! Stop the timer this % omp_end = omp_get_wtime () ! Calculate the elapsed OMP time this % omp_elapsed = this % omp_end - this % omp_start ! Convert OMP time to seconds if (. not . present ( nloops )) this % omp_time = this % omp_elapsed if ( present ( nloops )) this % omp_time = this % omp_elapsed / real ( nloops , kind = rk ) ! Print the elapsed time if (. not . present ( message )) then msg = \"OMP time:\" else msg = message end if print '(A, F16.9, \" [s]\")' , trim ( msg ), this % omp_time ! Deallocate the message if ( allocated ( msg )) deallocate ( msg ) end subroutine otimer_stop","tags":"","loc":"proc/otimer_stop.html"},{"title":"otimer_write – ForTime","text":"private impure subroutine otimer_write(this, file_name) Uses omp_lib proc~~otimer_write~~UsesGraph proc~otimer_write fortime::timer%otimer_write omp_lib omp_lib proc~otimer_write->omp_lib Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Writes the OMP time to a file. Type Bound timer Arguments Type Intent Optional Attributes Name class( timer ), intent(in) :: this character(len=*), intent(in) :: file_name Source Code impure subroutine otimer_write ( this , file_name ) use omp_lib class ( timer ), intent ( in ) :: this character ( * ), intent ( in ) :: file_name logical :: file_exists integer :: nunit ! Check if the file exists inquire ( file = file_name , exist = file_exists ) ! Open the file in appropriate mode if ( file_exists ) then open ( newunit = nunit , file = file_name , status = 'old' , action = 'write' , position = 'append' ) else open ( newunit = nunit , file = file_name , status = 'new' , action = 'write' ) end if ! Write the OMP time to the file write ( nunit , '(g0)' ) this % omp_time ! Close the file close ( nunit ) end subroutine otimer_write","tags":"","loc":"proc/otimer_write.html"},{"title":"mtimer_start – ForTime","text":"private impure subroutine mtimer_start(this) Starts the timer by recording the current MPI time value.\nThis value is used to calculate the MPI time later. Type Bound timer Arguments Type Intent Optional Attributes Name class( timer ), intent(inout) :: this Source Code impure subroutine mtimer_start ( this ) ! include 'mpif.h' class ( timer ), intent ( inout ) :: this interface function mpi_wtime () import rk real ( rk ) :: mpi_wtime end function mpi_wtime end interface ! Start the timer this % mpi_start = mpi_wtime () end subroutine mtimer_start","tags":"","loc":"proc/mtimer_start.html"},{"title":"mtimer_stop – ForTime","text":"private impure subroutine mtimer_stop(this, nloops, message) Stops the timer and calculates the MPI time.\nOptionally, it can print a message along with the MPI time. Type Bound timer Arguments Type Intent Optional Attributes Name class( timer ), intent(inout) :: this integer, intent(in), optional :: nloops character(len=*), intent(in), optional :: message Source Code impure subroutine mtimer_stop ( this , nloops , message ) ! include 'mpif.h' class ( timer ), intent ( inout ) :: this integer , intent ( in ), optional :: nloops character ( * ), intent ( in ), optional :: message character (:), allocatable :: msg interface function mpi_wtime () import rk real ( rk ) :: mpi_wtime end function mpi_wtime end interface ! Stop the timer this % mpi_end = mpi_wtime () ! Calculate the elapsed MPI time this % mpi_elapsed = this % mpi_end - this % mpi_start ! Convert MPI time to seconds if (. not . present ( nloops )) this % mpi_time = this % mpi_elapsed if ( present ( nloops )) this % mpi_time = this % mpi_elapsed / real ( nloops , kind = rk ) ! Print the elapsed time if (. not . present ( message )) then msg = \"MPI time:\" else msg = message end if print '(A, F16.9, \" [s]\")' , trim ( msg ), this % mpi_time ! Deallocate the message if ( allocated ( msg )) deallocate ( msg ) end subroutine mtimer_stop","tags":"","loc":"proc/mtimer_stop.html"},{"title":"mtimer_write – ForTime","text":"private impure subroutine mtimer_write(this, file_name) Writes the MPI time to a file. Type Bound timer Arguments Type Intent Optional Attributes Name class( timer ), intent(in) :: this character(len=*), intent(in) :: file_name Source Code impure subroutine mtimer_write ( this , file_name ) class ( timer ), intent ( in ) :: this character ( * ), intent ( in ) :: file_name logical :: file_exists integer :: nunit ! Check if the file exists inquire ( file = file_name , exist = file_exists ) ! Open the file in appropriate mode if ( file_exists ) then open ( newunit = nunit , file = file_name , status = 'old' , action = 'write' , position = 'append' ) else open ( newunit = nunit , file = file_name , status = 'new' , action = 'write' ) end if ! Write the MPI time to the file write ( nunit , '(g0)' ) this % mpi_time ! Close the file close ( nunit ) end subroutine mtimer_write","tags":"","loc":"proc/mtimer_write.html"},{"title":"fortime – ForTime","text":"This module provides a timer object for measuring elapsed time.\nIt includes procedures for starting and stopping the timer, as well\nas calculating and printing the elapsed time in seconds. Uses kinds module~~fortime~~UsesGraph module~fortime fortime kinds kinds module~fortime->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~fortime~~UsedByGraph module~fortime fortime program~example1 example1 program~example1->module~fortime program~example2 example2 program~example2->module~fortime program~example3 example3 program~example3->module~fortime program~example4 example4 program~example4->module~fortime Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: timer Components Type Visibility Attributes Name Initial integer, public :: clock_rate integer, public :: clock_start integer, public :: clock_end integer, public :: clock_elapsed real(kind=rk), public :: elapsed_time real(kind=rk), public :: cpu_start real(kind=rk), public :: cpu_end real(kind=rk), public :: cpu_elapsed real(kind=rk), public :: cpu_time real(kind=rk), public :: omp_start real(kind=rk), public :: omp_end real(kind=rk), public :: omp_elapsed real(kind=rk), public :: omp_time real(kind=rk), public :: mpi_start real(kind=rk), public :: mpi_end real(kind=rk), public :: mpi_elapsed real(kind=rk), public :: mpi_time Type-Bound Procedures procedure, public :: timer_start procedure, public :: timer_stop procedure, public :: timer_write procedure, public :: ctimer_start procedure, public :: ctimer_stop procedure, public :: ctimer_write procedure, public :: otimer_start procedure, public :: otimer_stop procedure, public :: otimer_write procedure, public :: mtimer_start procedure, public :: mtimer_stop procedure, public :: mtimer_write Subroutines public impure subroutine timer_start (this) Author Seyed Ali Ghasemi Starts the timer by recording the current processor clock value.\nThis value is used to calculate the elapsed time later. Arguments Type Intent Optional Attributes Name class( timer ), intent(inout) :: this public impure subroutine timer_stop (this, nloops, message) Author Seyed Ali Ghasemi Stops the timer and calculates the elapsed time.\nOptionally, it can print a message along with the elapsed time. Arguments Type Intent Optional Attributes Name class( timer ), intent(inout) :: this integer, intent(in), optional :: nloops character(len=*), intent(in), optional :: message private impure subroutine timer_write (this, file_name) Author Seyed Ali Ghasemi Writes the elapsed time to a file. Arguments Type Intent Optional Attributes Name class( timer ), intent(in) :: this character(len=*), intent(in) :: file_name private impure subroutine ctimer_start (this) Author Seyed Ali Ghasemi Starts the timer by recording the current CPU time value.\nThis value is used to calculate the CPU time later. Arguments Type Intent Optional Attributes Name class( timer ), intent(inout) :: this private impure subroutine ctimer_stop (this, nloops, message) Author Seyed Ali Ghasemi Stops the timer and calculates the CPU time.\nOptionally, it can print a message along with the CPU time. Arguments Type Intent Optional Attributes Name class( timer ), intent(inout) :: this integer, intent(in), optional :: nloops character(len=*), intent(in), optional :: message private impure subroutine ctimer_write (this, file_name) Author Seyed Ali Ghasemi Writes the CPU time to a file. Arguments Type Intent Optional Attributes Name class( timer ), intent(in) :: this character(len=*), intent(in) :: file_name private impure subroutine otimer_start (this) Author Seyed Ali Ghasemi Starts the timer by recording the current OMP time value.\nThis value is used to calculate the OMP time later. Arguments Type Intent Optional Attributes Name class( timer ), intent(inout) :: this private impure subroutine otimer_stop (this, nloops, message) Author Seyed Ali Ghasemi Stops the timer and calculates the OMP time.\nOptionally, it can print a message along with the OMP time. Arguments Type Intent Optional Attributes Name class( timer ), intent(inout) :: this integer, intent(in), optional :: nloops character(len=*), intent(in), optional :: message private impure subroutine otimer_write (this, file_name) Author Seyed Ali Ghasemi Writes the OMP time to a file. Arguments Type Intent Optional Attributes Name class( timer ), intent(in) :: this character(len=*), intent(in) :: file_name private impure subroutine mtimer_start (this) Author Seyed Ali Ghasemi Starts the timer by recording the current MPI time value.\nThis value is used to calculate the MPI time later. Arguments Type Intent Optional Attributes Name class( timer ), intent(inout) :: this private impure subroutine mtimer_stop (this, nloops, message) Author Seyed Ali Ghasemi Stops the timer and calculates the MPI time.\nOptionally, it can print a message along with the MPI time. Arguments Type Intent Optional Attributes Name class( timer ), intent(inout) :: this integer, intent(in), optional :: nloops character(len=*), intent(in), optional :: message private impure subroutine mtimer_write (this, file_name) Author Seyed Ali Ghasemi Writes the MPI time to a file. Arguments Type Intent Optional Attributes Name class( timer ), intent(in) :: this character(len=*), intent(in) :: file_name","tags":"","loc":"module/fortime.html"},{"title":"example2 – ForTime","text":"Uses fortime program~~example2~~UsesGraph program~example2 example2 module~fortime fortime program~example2->module~fortime kinds kinds module~fortime->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~example2~~CallsGraph program~example2 example2 proc~timer_start fortime::timer%timer_start program~example2->proc~timer_start proc~timer_stop fortime::timer%timer_stop program~example2->proc~timer_stop proc~timer_write fortime::timer%timer_write program~example2->proc~timer_write Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( timer ) :: t integer :: i integer :: n = 3 Source Code program example2 use fortime implicit none type ( timer ) :: t integer :: i , n = 3 call t % timer_start () do i = 1 , n call sleep ( 1 ) ! Perform operations ntimes end do call t % timer_stop ( nloops = n , message = 'Elapsed time:' ) call t % timer_write ( 'example/example2_etimes' ) ! Optionally, write the elapsed time to a file end program example2","tags":"","loc":"program/example2.html"},{"title":"example1 – ForTime","text":"Uses fortime program~~example1~~UsesGraph program~example1 example1 module~fortime fortime program~example1->module~fortime kinds kinds module~fortime->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~example1~~CallsGraph program~example1 example1 proc~timer_start fortime::timer%timer_start program~example1->proc~timer_start proc~timer_stop fortime::timer%timer_stop program~example1->proc~timer_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( timer ) :: t Source Code program example1 use fortime implicit none type ( timer ) :: t call t % timer_start () call sleep ( 1 ) ! Perform operations here call t % timer_stop () end program example1","tags":"","loc":"program/example1.html"},{"title":"example3 – ForTime","text":"Uses fortime program~~example3~~UsesGraph program~example3 example3 module~fortime fortime program~example3->module~fortime kinds kinds module~fortime->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~example3~~CallsGraph program~example3 example3 proc~ctimer_start fortime::timer%ctimer_start program~example3->proc~ctimer_start proc~ctimer_stop fortime::timer%ctimer_stop program~example3->proc~ctimer_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( timer ) :: t Source Code program example3 use fortime implicit none type ( timer ) :: t call t % ctimer_start () call sleep ( 1 ) ! Perform operations here call t % ctimer_stop () end program example3","tags":"","loc":"program/example3.html"},{"title":"example4 – ForTime","text":"Uses fortime program~~example4~~UsesGraph program~example4 example4 module~fortime fortime program~example4->module~fortime kinds kinds module~fortime->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~example4~~CallsGraph program~example4 example4 proc~ctimer_start fortime::timer%ctimer_start program~example4->proc~ctimer_start proc~ctimer_stop fortime::timer%ctimer_stop program~example4->proc~ctimer_stop proc~ctimer_write fortime::timer%ctimer_write program~example4->proc~ctimer_write Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( timer ) :: t integer :: i integer :: n = 3 Source Code program example4 use fortime implicit none type ( timer ) :: t integer :: i , n = 3 call t % ctimer_start () do i = 1 , n call sleep ( 1 ) ! Perform operations ntimes end do call t % ctimer_stop ( nloops = n , message = 'CPU time:' ) call t % ctimer_write ( 'example/example4_ctimes' ) ! Optionally, write the elapsed time to a file end program example4","tags":"","loc":"program/example4.html"},{"title":"example2.f90 – ForTime","text":"This file depends on sourcefile~~example2.f90~~EfferentGraph sourcefile~example2.f90 example2.f90 sourcefile~fortime.f90 fortime.f90 sourcefile~example2.f90->sourcefile~fortime.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program example2 use fortime implicit none type ( timer ) :: t integer :: i , n = 3 call t % timer_start () do i = 1 , n call sleep ( 1 ) ! Perform operations ntimes end do call t % timer_stop ( nloops = n , message = 'Elapsed time:' ) call t % timer_write ( 'example/example2_etimes' ) ! Optionally, write the elapsed time to a file end program example2","tags":"","loc":"sourcefile/example2.f90.html"},{"title":"example1.f90 – ForTime","text":"This file depends on sourcefile~~example1.f90~~EfferentGraph sourcefile~example1.f90 example1.f90 sourcefile~fortime.f90 fortime.f90 sourcefile~example1.f90->sourcefile~fortime.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program example1 use fortime implicit none type ( timer ) :: t call t % timer_start () call sleep ( 1 ) ! Perform operations here call t % timer_stop () end program example1","tags":"","loc":"sourcefile/example1.f90.html"},{"title":"fortime.f90 – ForTime","text":"Files dependent on this one sourcefile~~fortime.f90~~AfferentGraph sourcefile~fortime.f90 fortime.f90 sourcefile~example1.f90 example1.f90 sourcefile~example1.f90->sourcefile~fortime.f90 sourcefile~example2.f90 example2.f90 sourcefile~example2.f90->sourcefile~fortime.f90 sourcefile~example3.f90 example3.f90 sourcefile~example3.f90->sourcefile~fortime.f90 sourcefile~example4.f90 example4.f90 sourcefile~example4.f90->sourcefile~fortime.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> This module provides a timer object for measuring elapsed time. !> It includes procedures for starting and stopping the timer, as well !> as calculating and printing the elapsed time in seconds. module fortime use kinds implicit none private public :: timer , timer_start , timer_stop !=============================================================================== type :: timer integer :: clock_rate ! Processor clock rate integer :: clock_start ! Start time in processor ticks integer :: clock_end ! End time in processor ticks integer :: clock_elapsed ! Elapsed time in processor ticks real ( rk ) :: elapsed_time ! Elapsed time in seconds real ( rk ) :: cpu_start ! Start CPU time real ( rk ) :: cpu_end ! End CPU time real ( rk ) :: cpu_elapsed ! Elapsed CPU time real ( rk ) :: cpu_time ! Elapsed time in seconds #if defined(USE_OMP) real ( rk ) :: omp_start ! Start OMP time real ( rk ) :: omp_end ! End OMP time real ( rk ) :: omp_elapsed ! Elapsed OMP time real ( rk ) :: omp_time ! Elapsed time in seconds #endif #if defined(USE_MPI) real ( rk ) :: mpi_start ! Start MPI time real ( rk ) :: mpi_end ! End MPI time real ( rk ) :: mpi_elapsed ! Elapsed MPI time real ( rk ) :: mpi_time ! Elapsed time in seconds #endif contains procedure :: timer_start ! Procedure for starting the timer procedure :: timer_stop ! Procedure for stopping the timer procedure :: timer_write ! Procedure for writing elapsed time to a file procedure :: ctimer_start ! Procedure for starting the CPU timer procedure :: ctimer_stop ! Procedure for stopping the CPU timer procedure :: ctimer_write ! Procedure for writing elapsed CPU time to a file #if defined(USE_OMP) procedure :: otimer_start ! Procedure for starting the OMP timer procedure :: otimer_stop ! Procedure for stopping the OMP timer procedure :: otimer_write ! Procedure for writing elapsed OMP time to a file #endif #if defined(USE_MPI) procedure :: mtimer_start ! Procedure for starting the MPI timer procedure :: mtimer_stop ! Procedure for stopping the MPI timer procedure :: mtimer_write ! Procedure for writing elapsed MPI time to a file #endif end type !=============================================================================== contains !=============================================================================== !> author: Seyed Ali Ghasemi !> Starts the timer by recording the current processor clock value. !> This value is used to calculate the elapsed time later. impure subroutine timer_start ( this ) class ( timer ), intent ( inout ) :: this ! Get the processor clock rate call system_clock ( count_rate = this % clock_rate ) ! Start the timer call system_clock ( count = this % clock_start ) end subroutine timer_start !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> Stops the timer and calculates the elapsed time. !> Optionally, it can print a message along with the elapsed time. impure subroutine timer_stop ( this , nloops , message ) class ( timer ), intent ( inout ) :: this integer , intent ( in ), optional :: nloops character ( * ), intent ( in ), optional :: message character (:), allocatable :: msg ! Stop the timer call system_clock ( count = this % clock_end ) ! Calculate the elapsed processor ticks this % clock_elapsed = this % clock_end - this % clock_start ! Convert processor ticks to seconds if (. not . present ( nloops )) & this % elapsed_time = real ( this % clock_elapsed , kind = rk ) / real ( this % clock_rate , kind = rk ) if ( present ( nloops )) & this % elapsed_time = real ( this % clock_elapsed , kind = rk ) / real ( this % clock_rate , kind = rk ) / real ( nloops , kind = rk ) ! Print the elapsed time if (. not . present ( message )) then msg = \"Elapsed time:\" else msg = message end if print '(A, F7.3, \" [s]\")' , trim ( msg ), this % elapsed_time ! Deallocate the message if ( allocated ( msg )) deallocate ( msg ) end subroutine timer_stop !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> Writes the elapsed time to a file. impure subroutine timer_write ( this , file_name ) class ( timer ), intent ( in ) :: this character ( * ), intent ( in ) :: file_name logical :: file_exists integer :: nunit ! Check if the file exists inquire ( file = file_name , exist = file_exists ) ! Open the file in appropriate mode if ( file_exists ) then open ( newunit = nunit , file = file_name , status = 'old' , action = 'write' , position = 'append' ) else open ( newunit = nunit , file = file_name , status = 'new' , action = 'write' ) end if ! Write the elapsed time to the file write ( nunit , '(g0)' ) this % elapsed_time ! Close the file close ( nunit ) end subroutine timer_write !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> Starts the timer by recording the current CPU time value. !> This value is used to calculate the CPU time later. impure subroutine ctimer_start ( this ) class ( timer ), intent ( inout ) :: this ! Start the timer call cpu_time ( this % cpu_start ) end subroutine ctimer_start !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> Stops the timer and calculates the CPU time. !> Optionally, it can print a message along with the CPU time. impure subroutine ctimer_stop ( this , nloops , message ) class ( timer ), intent ( inout ) :: this integer , intent ( in ), optional :: nloops character ( * ), intent ( in ), optional :: message character (:), allocatable :: msg ! Stop the timer call cpu_time ( this % cpu_end ) ! Calculate the elapsed CPU time this % cpu_elapsed = this % cpu_end - this % cpu_start ! Convert CPU time to seconds if (. not . present ( nloops )) this % cpu_time = this % cpu_elapsed if ( present ( nloops )) this % cpu_time = this % cpu_elapsed / real ( nloops , kind = rk ) ! Print the elapsed time if (. not . present ( message )) then msg = \"CPU time:\" else msg = message end if print '(A, F16.9, \" [s]\")' , trim ( msg ), this % cpu_time ! Deallocate the message if ( allocated ( msg )) deallocate ( msg ) end subroutine ctimer_stop !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> Writes the CPU time to a file. impure subroutine ctimer_write ( this , file_name ) class ( timer ), intent ( in ) :: this character ( * ), intent ( in ) :: file_name logical :: file_exists integer :: nunit ! Check if the file exists inquire ( file = file_name , exist = file_exists ) ! Open the file in appropriate mode if ( file_exists ) then open ( newunit = nunit , file = file_name , status = 'old' , action = 'write' , position = 'append' ) else open ( newunit = nunit , file = file_name , status = 'new' , action = 'write' ) end if ! Write the CPU time to the file write ( nunit , '(g0)' ) this % cpu_time ! Close the file close ( nunit ) end subroutine ctimer_write !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> Starts the timer by recording the current OMP time value. !> This value is used to calculate the OMP time later. #if defined(USE_OMP) impure subroutine otimer_start ( this ) use omp_lib class ( timer ), intent ( inout ) :: this ! Start the timer this % omp_start = omp_get_wtime () end subroutine otimer_start !=============================================================================== #endif #if defined(USE_OMP) !=============================================================================== !> author: Seyed Ali Ghasemi !> Stops the timer and calculates the OMP time. !> Optionally, it can print a message along with the OMP time. impure subroutine otimer_stop ( this , nloops , message ) use omp_lib class ( timer ), intent ( inout ) :: this integer , intent ( in ), optional :: nloops character ( * ), intent ( in ), optional :: message character (:), allocatable :: msg ! Stop the timer this % omp_end = omp_get_wtime () ! Calculate the elapsed OMP time this % omp_elapsed = this % omp_end - this % omp_start ! Convert OMP time to seconds if (. not . present ( nloops )) this % omp_time = this % omp_elapsed if ( present ( nloops )) this % omp_time = this % omp_elapsed / real ( nloops , kind = rk ) ! Print the elapsed time if (. not . present ( message )) then msg = \"OMP time:\" else msg = message end if print '(A, F16.9, \" [s]\")' , trim ( msg ), this % omp_time ! Deallocate the message if ( allocated ( msg )) deallocate ( msg ) end subroutine otimer_stop !=============================================================================== #endif #if defined(USE_OMP) !=============================================================================== !> author: Seyed Ali Ghasemi !> Writes the OMP time to a file. impure subroutine otimer_write ( this , file_name ) use omp_lib class ( timer ), intent ( in ) :: this character ( * ), intent ( in ) :: file_name logical :: file_exists integer :: nunit ! Check if the file exists inquire ( file = file_name , exist = file_exists ) ! Open the file in appropriate mode if ( file_exists ) then open ( newunit = nunit , file = file_name , status = 'old' , action = 'write' , position = 'append' ) else open ( newunit = nunit , file = file_name , status = 'new' , action = 'write' ) end if ! Write the OMP time to the file write ( nunit , '(g0)' ) this % omp_time ! Close the file close ( nunit ) end subroutine otimer_write !=============================================================================== #endif #if defined(USE_MPI) !=============================================================================== !> author: Seyed Ali Ghasemi !> Starts the timer by recording the current MPI time value. !> This value is used to calculate the MPI time later. impure subroutine mtimer_start ( this ) ! include 'mpif.h' class ( timer ), intent ( inout ) :: this interface function mpi_wtime () import rk real ( rk ) :: mpi_wtime end function mpi_wtime end interface ! Start the timer this % mpi_start = mpi_wtime () end subroutine mtimer_start !=============================================================================== #endif #if defined(USE_MPI) !=============================================================================== !> author: Seyed Ali Ghasemi !> Stops the timer and calculates the MPI time. !> Optionally, it can print a message along with the MPI time. impure subroutine mtimer_stop ( this , nloops , message ) ! include 'mpif.h' class ( timer ), intent ( inout ) :: this integer , intent ( in ), optional :: nloops character ( * ), intent ( in ), optional :: message character (:), allocatable :: msg interface function mpi_wtime () import rk real ( rk ) :: mpi_wtime end function mpi_wtime end interface ! Stop the timer this % mpi_end = mpi_wtime () ! Calculate the elapsed MPI time this % mpi_elapsed = this % mpi_end - this % mpi_start ! Convert MPI time to seconds if (. not . present ( nloops )) this % mpi_time = this % mpi_elapsed if ( present ( nloops )) this % mpi_time = this % mpi_elapsed / real ( nloops , kind = rk ) ! Print the elapsed time if (. not . present ( message )) then msg = \"MPI time:\" else msg = message end if print '(A, F16.9, \" [s]\")' , trim ( msg ), this % mpi_time ! Deallocate the message if ( allocated ( msg )) deallocate ( msg ) end subroutine mtimer_stop !=============================================================================== #endif #if defined(USE_MPI) !=============================================================================== !> author: Seyed Ali Ghasemi !> Writes the MPI time to a file. impure subroutine mtimer_write ( this , file_name ) class ( timer ), intent ( in ) :: this character ( * ), intent ( in ) :: file_name logical :: file_exists integer :: nunit ! Check if the file exists inquire ( file = file_name , exist = file_exists ) ! Open the file in appropriate mode if ( file_exists ) then open ( newunit = nunit , file = file_name , status = 'old' , action = 'write' , position = 'append' ) else open ( newunit = nunit , file = file_name , status = 'new' , action = 'write' ) end if ! Write the MPI time to the file write ( nunit , '(g0)' ) this % mpi_time ! Close the file close ( nunit ) end subroutine mtimer_write !=============================================================================== #endif end module fortime","tags":"","loc":"sourcefile/fortime.f90.html"},{"title":"example3.f90 – ForTime","text":"This file depends on sourcefile~~example3.f90~~EfferentGraph sourcefile~example3.f90 example3.f90 sourcefile~fortime.f90 fortime.f90 sourcefile~example3.f90->sourcefile~fortime.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program example3 use fortime implicit none type ( timer ) :: t call t % ctimer_start () call sleep ( 1 ) ! Perform operations here call t % ctimer_stop () end program example3","tags":"","loc":"sourcefile/example3.f90.html"},{"title":"example4.f90 – ForTime","text":"This file depends on sourcefile~~example4.f90~~EfferentGraph sourcefile~example4.f90 example4.f90 sourcefile~fortime.f90 fortime.f90 sourcefile~example4.f90->sourcefile~fortime.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program example4 use fortime implicit none type ( timer ) :: t integer :: i , n = 3 call t % ctimer_start () do i = 1 , n call sleep ( 1 ) ! Perform operations ntimes end do call t % ctimer_stop ( nloops = n , message = 'CPU time:' ) call t % ctimer_write ( 'example/example4_ctimes' ) ! Optionally, write the elapsed time to a file end program example4","tags":"","loc":"sourcefile/example4.f90.html"}]}